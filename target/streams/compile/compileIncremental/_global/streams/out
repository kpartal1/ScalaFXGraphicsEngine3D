[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial source changes: [0m
[0m[[0m[0mdebug[0m] [0m[0m	removed:Set(\Users\konstantits\Documents\mud-s21-kpartal1\src\main\scala\mud\Item.scala, \Users\konstantits\Documents\mud-s21-kpartal1\src\main\scala\tester\IOConfig.scala, \Users\konstantits\Documents\mud-s21-kpartal1\src\main\scala\mud\Player.scala, \Users\konstantits\Documents\mud-s21-kpartal1\src\main\scala\mud\PlayerManager.scala, \Users\konstantits\Documents\mud-s21-kpartal1\src\main\scala\tester\CommandArguments.scala, \Users\konstantits\Documents\mud-s21-kpartal1\src\main\scala\mud\Room.scala, \Users\konstantits\Documents\mud-s21-kpartal1\src\main\scala\tester\Player.scala, \Users\konstantits\Documents\mud-s21-kpartal1\src\main\scala\mud\Main.scala, \Users\konstantits\Documents\mud-s21-kpartal1\src\main\scala\tester\Command.scala, \Users\konstantits\Documents\mud-s21-kpartal1\src\main\scala\tester\Debug.scala, \Users\konstantits\Documents\mud-s21-kpartal1\src\main\scala\mud\RoomManager.scala, \Users\konstantits\Documents\mud-s21-kpartal1\src\main\scala\tester\TestPlayer.scala, \Users\konstantits\Documents\mud-s21-kpartal1\src\main\scala\tester\SimpleTest.scala)[0m
[0m[[0m[0mdebug[0m] [0m[0m	added: Set(C:\Users\12103\Documents\CodingProjects\GraphicsEngine3D\src\main\scala\graphicsengine3d\Main.scala)[0m
[0m[[0m[0mdebug[0m] [0m[0m	modified: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated products: Set(\Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\tester\TestPlayer$Disconnect$.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\mud\PlayerManager$PrivateMessage$.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\tester\RoomOccupant$.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\mud\PlayerManager$NewUser.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\mud\Room$BroadcastInRoom.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\tester\Debug.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\tester\TestPlayer$.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\tester\IOConfig.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\tester\IOConfig$.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\mud\PlayerManager$LocatePlayer$.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\mud\PlayerManager$LocatePlayer.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\mud\Player.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\mud\Room$.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\tester\Player$GameState.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\tester\SimpleTest$delayedInit$body.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\mud\Main$.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\mud\RoomManager$.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\mud\PlayerManager$$anonfun$receive$1.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\tester\InvParsing$.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\tester\SimpleTest.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\mud\Room$AddPlayer$.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\mud\Room$AddPlayer.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\tester\ConstantArg.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\mud\Room$GetExit$.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\tester\Debug$.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\tester\ConstantArg$.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\tester\TestPlayer$GetDropTest$.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\mud\Room$GetItem$.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\tester\Player$KillPlayer$.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\mud\Room$LinkExits$.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\mud\Player$.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\tester\IOElement$.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\mud\Room$BroadcastInRoom$.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\mud\PlayerManager$PrivateMessage.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\mud\Item$.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\mud\Player$PickItem$.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\mud\Item.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\tester\RoomExit.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\mud\PlayerManager$CheckInput$.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\mud\Room$RemovePlayer$.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\mud\Room$GetItem.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\mud\RoomManager$$anonfun$receive$1.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\tester\Player.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\tester\Player$.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\mud\PlayerManager.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\tester\CommandArgument.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\tester\TestPlayer$$anonfun$receive$1.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\mud\Player$$anonfun$receive$1.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\mud\Player$StartRoom.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\tester\RoomParsing.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\tester\Unparsed.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\mud\RoomManager.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\tester\Player$GameState$.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\mud\Player$GetCurrentRoom$.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\mud\PlayerManager$NewUser$.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\tester\InvItem.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\mud\Room$DropItem$.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\mud\Player$VerifyInput$.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\mud\Player$PrintMessage.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\tester\Unparsed$.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\tester\TestPlayer.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\mud\Room$LinkExits.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\tester\InvItem$.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\mud\Player$TakeExit.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\mud\Player$Init.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\mud\Room$PlayersInRoom.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\tester\RoomExit$.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\tester\SimpleTest$.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\mud\Room$FullDescription$.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\tester\Player$Disconnect$.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\tester\RoomItem$.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\mud\Room$GetExit.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\mud\Player$Init$.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\mud\Room$PlayersInRoom$.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\tester\RoomParsing$.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\tester\RoomItem.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\mud\Player$PickItem.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\tester\RoomOccupant.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\mud\Player$PrintMessage$.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\mud\Room.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\mud\Room$DropItem.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\tester\Command$.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\mud\Player$TakeExit$.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\mud\Room$RemovePlayer.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\mud\PlayerManager$.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\mud\Room$$anonfun$receive$1.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\mud\Main.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\tester\Command.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\mud\Player$StartRoom$.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\tester\InvParsing.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\mud\RoomManager$BeginGame$.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\tester\Player$Connect$.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\tester\CommandArgument$.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\tester\IOElement.class, \Users\konstantits\Documents\mud-s21-kpartal1\target\scala-2.12\classes\mud\PlayerManager$Init$.class)[0m
[0m[[0m[0mdebug[0m] [0m[0mExternal API changes: API Changes: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mModified binary dependencies: Set(C:\Users\12103\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\openjfx\javafx-fxml\11\javafx-fxml-11-win.jar, C:\Users\12103\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\openjfx\javafx-graphics\11\javafx-graphics-11-win.jar, \Users\konstantits\Library\Caches\Coursier\v1\https\repo1.maven.org\maven2\org\scala-lang\scala-reflect\2.12.12\scala-reflect-2.12.12.jar, \Users\konstantits\Library\Caches\Coursier\v1\https\repo1.maven.org\maven2\org\scala-lang\modules\scala-xml_2.12\1.3.0\scala-xml_2.12-1.3.0.jar, C:\Users\12103\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\scalactic\scalactic_2.12\3.2.2\scalactic_2.12-3.2.2.jar, \Users\konstantits\Library\Caches\Coursier\v1\https\repo1.maven.org\maven2\com\typesafe\config\1.4.0\config-1.4.0.jar, C:\Users\12103\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\scalafx\scalafx_2.12\11-R16\scalafx_2.12-11-R16.jar, \Users\konstantits\Library\Caches\Coursier\v1\https\repo1.maven.org\maven2\org\scala-lang\scala-library\2.12.12\scala-library-2.12.12.jar, C:\Users\12103\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\openjfx\javafx-media\11\javafx-media-11-win.jar, C:\Users\12103\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\openjfx\javafx-graphics\11\javafx-graphics-11.jar, C:\Users\12103\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\scala-lang\scala-library\2.12.12\scala-library-2.12.12.jar, C:\Users\12103\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\openjfx\javafx-media\11\javafx-media-11.jar, C:\Users\12103\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\openjfx\javafx-controls\11\javafx-controls-11.jar, C:\Users\12103\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\scala-lang\scala-reflect\2.12.12\scala-reflect-2.12.12.jar, C:\Users\12103\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\openjfx\javafx-swing\11\javafx-swing-11-win.jar, \Users\konstantits\Library\Caches\Coursier\v1\https\repo1.maven.org\maven2\org\scala-lang\modules\scala-java8-compat_2.12\0.8.0\scala-java8-compat_2.12-0.8.0.jar, C:\Users\12103\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\openjfx\javafx-base\11\javafx-base-11-win.jar, C:\Users\12103\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\openjfx\javafx-controls\11\javafx-controls-11-win.jar, C:\Users\12103\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\openjfx\javafx-web\11\javafx-web-11-win.jar, \Users\konstantits\Library\Caches\Coursier\v1\https\repo1.maven.org\maven2\com\typesafe\akka\akka-actor_2.12\2.6.8\akka-actor_2.12-2.6.8.jar, \Users\konstantits\Library\Caches\Coursier\v1\https\repo1.maven.org\maven2\org\scalactic\scalactic_2.12\3.2.2\scalactic_2.12-3.2.2.jar, C:\Users\12103\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\openjfx\javafx-base\11\javafx-base-11.jar)[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial directly invalidated classes: Set(tester.RoomOccupant, tester.Player.KillPlayer, tester.Player.Connect, mud.PlayerManager.PrivateMessage, mud.PlayerManager.LocatePlayer, tester.InvItem, tester.RoomItem, tester.Command, mud.Room.RemovePlayer, tester.TestPlayer.GetDropTest, tester.TestPlayer.Disconnect, mud.Room.LinkExits, mud.RoomManager.BeginGame, mud.Player.GetCurrentRoom, tester.RoomParsing, mud.Player.PrintMessage, mud.Room.DropItem, mud.Room.AddPlayer, mud.Room.BroadcastInRoom, tester.Debug, tester.RoomExit, mud.Room.GetItem, mud.PlayerManager.CheckInput, mud.Room.FullDescription, tester.Player.Disconnect, mud.Player.PickItem, mud.PlayerManager.NewUser, tester.IOElement, tester.IOConfig, mud.Main, tester.InvParsing, mud.PlayerManager, mud.PlayerManager.Init, tester.Unparsed, mud.Room.GetExit, tester.SimpleTest, mud.Player, tester.Player.GameState, tester.CommandArgument, mud.Player.VerifyInput, mud.Item, mud.RoomManager, mud.Player.TakeExit, mud.Player.Init, tester.Player, mud.Room, tester.TestPlayer, tester.ConstantArg, mud.Room.PlayersInRoom, mud.Player.StartRoom)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mSources indirectly invalidated by:[0m
[0m[[0m[0mdebug[0m] [0m[0m	product: Set(\Users\konstantits\Documents\mud-s21-kpartal1\src\main\scala\mud\Item.scala, \Users\konstantits\Documents\mud-s21-kpartal1\src\main\scala\tester\IOConfig.scala, \Users\konstantits\Documents\mud-s21-kpartal1\src\main\scala\mud\Player.scala, \Users\konstantits\Documents\mud-s21-kpartal1\src\main\scala\mud\PlayerManager.scala, \Users\konstantits\Documents\mud-s21-kpartal1\src\main\scala\tester\CommandArguments.scala, \Users\konstantits\Documents\mud-s21-kpartal1\src\main\scala\mud\Room.scala, \Users\konstantits\Documents\mud-s21-kpartal1\src\main\scala\tester\Player.scala, \Users\konstantits\Documents\mud-s21-kpartal1\src\main\scala\mud\Main.scala, \Users\konstantits\Documents\mud-s21-kpartal1\src\main\scala\tester\Command.scala, \Users\konstantits\Documents\mud-s21-kpartal1\src\main\scala\tester\Debug.scala, \Users\konstantits\Documents\mud-s21-kpartal1\src\main\scala\mud\RoomManager.scala, \Users\konstantits\Documents\mud-s21-kpartal1\src\main\scala\tester\TestPlayer.scala, \Users\konstantits\Documents\mud-s21-kpartal1\src\main\scala\tester\SimpleTest.scala)[0m
[0m[[0m[0mdebug[0m] [0m[0m	binary dep: Set(\Users\konstantits\Documents\mud-s21-kpartal1\src\main\scala\mud\Item.scala, \Users\konstantits\Documents\mud-s21-kpartal1\src\main\scala\tester\IOConfig.scala, \Users\konstantits\Documents\mud-s21-kpartal1\src\main\scala\mud\Player.scala, \Users\konstantits\Documents\mud-s21-kpartal1\src\main\scala\mud\PlayerManager.scala, \Users\konstantits\Documents\mud-s21-kpartal1\src\main\scala\tester\CommandArguments.scala, \Users\konstantits\Documents\mud-s21-kpartal1\src\main\scala\mud\Room.scala, \Users\konstantits\Documents\mud-s21-kpartal1\src\main\scala\tester\Player.scala, \Users\konstantits\Documents\mud-s21-kpartal1\src\main\scala\mud\Main.scala, \Users\konstantits\Documents\mud-s21-kpartal1\src\main\scala\tester\Command.scala, \Users\konstantits\Documents\mud-s21-kpartal1\src\main\scala\tester\Debug.scala, \Users\konstantits\Documents\mud-s21-kpartal1\src\main\scala\mud\RoomManager.scala, \Users\konstantits\Documents\mud-s21-kpartal1\src\main\scala\tester\TestPlayer.scala, \Users\konstantits\Documents\mud-s21-kpartal1\src\main\scala\tester\SimpleTest.scala)[0m
[0m[[0m[0mdebug[0m] [0m[0m	external source: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mAll initially invalidated classes: Set(tester.RoomOccupant, tester.Player.KillPlayer, tester.Player.Connect, mud.PlayerManager.PrivateMessage, mud.PlayerManager.LocatePlayer, tester.InvItem, tester.RoomItem, tester.Command, mud.Room.RemovePlayer, tester.TestPlayer.GetDropTest, tester.TestPlayer.Disconnect, mud.Room.LinkExits, mud.RoomManager.BeginGame, mud.Player.GetCurrentRoom, tester.RoomParsing, mud.Player.PrintMessage, mud.Room.DropItem, mud.Room.AddPlayer, mud.Room.BroadcastInRoom, tester.Debug, tester.RoomExit, mud.Room.GetItem, mud.PlayerManager.CheckInput, mud.Room.FullDescription, tester.Player.Disconnect, mud.Player.PickItem, mud.PlayerManager.NewUser, tester.IOElement, tester.IOConfig, mud.Main, tester.InvParsing, mud.PlayerManager, mud.PlayerManager.Init, tester.Unparsed, mud.Room.GetExit, tester.SimpleTest, mud.Player, tester.Player.GameState, tester.CommandArgument, mud.Player.VerifyInput, mud.Item, mud.RoomManager, mud.Player.TakeExit, mud.Player.Init, tester.Player, mud.Room, tester.TestPlayer, tester.ConstantArg, mud.Room.PlayersInRoom, mud.Player.StartRoom)[0m
[0m[[0m[0mdebug[0m] [0m[0mAll initially invalidated sources:Set(\Users\konstantits\Documents\mud-s21-kpartal1\src\main\scala\mud\Item.scala, \Users\konstantits\Documents\mud-s21-kpartal1\src\main\scala\tester\IOConfig.scala, \Users\konstantits\Documents\mud-s21-kpartal1\src\main\scala\mud\Player.scala, \Users\konstantits\Documents\mud-s21-kpartal1\src\main\scala\mud\PlayerManager.scala, \Users\konstantits\Documents\mud-s21-kpartal1\src\main\scala\tester\CommandArguments.scala, \Users\konstantits\Documents\mud-s21-kpartal1\src\main\scala\mud\Room.scala, C:\Users\12103\Documents\CodingProjects\GraphicsEngine3D\src\main\scala\graphicsengine3d\Main.scala, \Users\konstantits\Documents\mud-s21-kpartal1\src\main\scala\tester\Player.scala, \Users\konstantits\Documents\mud-s21-kpartal1\src\main\scala\mud\Main.scala, \Users\konstantits\Documents\mud-s21-kpartal1\src\main\scala\tester\Command.scala, \Users\konstantits\Documents\mud-s21-kpartal1\src\main\scala\tester\Debug.scala, \Users\konstantits\Documents\mud-s21-kpartal1\src\main\scala\mud\RoomManager.scala, \Users\konstantits\Documents\mud-s21-kpartal1\src\main\scala\tester\TestPlayer.scala, \Users\konstantits\Documents\mud-s21-kpartal1\src\main\scala\tester\SimpleTest.scala)[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: tester.RoomOccupant, tester.Player.KillPlayer, tester.Player.Connect, mud.PlayerManager.PrivateMessage, mud.PlayerManager.LocatePlayer, tester.InvItem, tester.RoomItem, tester.Command, mud.Room.RemovePlayer, tester.TestPlayer.GetDropTest, tester.TestPlayer.Disconnect, mud.Room.LinkExits, mud.RoomManager.BeginGame, mud.Player.GetCurrentRoom, tester.RoomParsing, mud.Player.PrintMessage, mud.Room.DropItem, mud.Room.AddPlayer, mud.Room.BroadcastInRoom, tester.Debug, tester.RoomExit, mud.Room.GetItem, mud.PlayerManager.CheckInput, mud.Room.FullDescription, tester.Player.Disconnect, mud.Player.PickItem, mud.PlayerManager.NewUser, tester.IOElement, tester.IOConfig, mud.Main, tester.InvParsing, mud.PlayerManager, mud.PlayerManager.Init, tester.Unparsed, mud.Room.GetExit, tester.SimpleTest, mud.Player, tester.Player.GameState, tester.CommandArgument, mud.Player.VerifyInput, mud.Item, mud.RoomManager, mud.Player.TakeExit, mud.Player.Init, tester.Player, mud.Room, tester.TestPlayer, tester.ConstantArg, mud.Room.PlayersInRoom, mud.Player.StartRoom[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding tester.RoomParsing by tester.Command[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding tester.InvParsing by tester.Command[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding tester.Unparsed by tester.Command[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding tester.ConstantArg by tester.CommandArgument[0m
[0m[[0m[0mdebug[0m] [0m[0mRecompiling all sources: number of invalidated sources > 50.0% of all sources[0m
[0m[[0m[0minfo[0m] [0m[0mCompiling 1 Scala source to C:\Users\12103\Documents\CodingProjects\GraphicsEngine3D\target\scala-2.12\classes ...[0m
[0m[[0m[0mdebug[0m] [0m[0mGetting org.scala-sbt:compiler-bridge_2.12:1.3.2:compile for Scala 2.12.12[0m
[0m[[0m[0mdebug[0m] [0m[0mGetting org.scala-sbt:compiler-bridge_2.12:1.3.2:compile for Scala 2.12.12[0m
[0m[[0m[0mdebug[0m] [0m[0m[zinc] Running cached compiler 261919b for Scala compiler version 2.12.12[0m
[0m[[0m[0mdebug[0m] [0m[0m[zinc] The Scala compiler is invoked with:[0m
[0m[[0m[0mdebug[0m] [0m[0m	-bootclasspath[0m
[0m[[0m[0mdebug[0m] [0m[0m	C:\Users\12103\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\scala-lang\scala-library\2.12.12\scala-library-2.12.12.jar[0m
[0m[[0m[0mdebug[0m] [0m[0m	-classpath[0m
[0m[[0m[0mdebug[0m] [0m[0m	C:\Users\12103\Documents\CodingProjects\GraphicsEngine3D\target\scala-2.12\classes;C:\Users\12103\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\scala-lang\scala-reflect\2.12.12\scala-reflect-2.12.12.jar;C:\Users\12103\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\openjfx\javafx-media\11\javafx-media-11.jar;C:\Users\12103\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\openjfx\javafx-base\11\javafx-base-11-win.jar;C:\Users\12103\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\openjfx\javafx-media\11\javafx-media-11-win.jar;C:\Users\12103\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\openjfx\javafx-controls\11\javafx-controls-11-win.jar;C:\Users\12103\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\openjfx\javafx-web\11\javafx-web-11-win.jar;C:\Users\12103\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\openjfx\javafx-graphics\11\javafx-graphics-11-win.jar;C:\Users\12103\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\openjfx\javafx-controls\11\javafx-controls-11.jar;C:\Users\12103\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\scalafx\scalafx_2.12\11-R16\scalafx_2.12-11-R16.jar;C:\Users\12103\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\openjfx\javafx-swing\11\javafx-swing-11-win.jar;C:\Users\12103\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\openjfx\javafx-base\11\javafx-base-11.jar;C:\Users\12103\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\openjfx\javafx-fxml\11\javafx-fxml-11-win.jar;C:\Users\12103\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\openjfx\javafx-graphics\11\javafx-graphics-11.jar;C:\Users\12103\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\scalactic\scalactic_2.12\3.2.2\scalactic_2.12-3.2.2.jar[0m
[0m[[0m[0mdebug[0m] [0m[0mScala compilation took 2.1258638 s[0m
[0m[[0m[0mdebug[0m] [0m[0mDone compiling.[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mud.PlayerManager...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: mud.PlayerManager[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mud.PlayerManager)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mud.PlayerManager,ModifiedNames(changes = UsedName(supervisorStrategy,[Default]), UsedName(aroundReceive,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(LocatePlayer,[Default]), UsedName(Receive,[Default]), UsedName(CheckInput,[Default]), UsedName(ne,[Default]), UsedName(self,[Implicit]), UsedName(postStop,[Default]), UsedName(asInstanceOf,[Default]), UsedName(Init,[Default]), UsedName(aroundPreRestart,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(unhandled,[Default]), UsedName(PrivateMessage,[Default]), UsedName(postRestart,[Default]), UsedName(receive,[Default]), UsedName(aroundPostRestart,[Default]), UsedName(finalize,[Default]), UsedName(mud;PlayerManager;init;,[Default]), UsedName(preRestart,[Default]), UsedName(aroundPreStart,[Default]), UsedName(sender,[Default]), UsedName(context,[Implicit]), UsedName(hashCode,[Default]), UsedName(preStart,[Default]), UsedName(NewUser,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(aroundPostStop,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(PlayerManager,[Default]), UsedName(!=,[Default]))) invalidates 1 classes due to The mud.PlayerManager has the following implicit definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(self,[Implicit]), UsedName(context,[Implicit]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mud.PlayerManager)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mud.Room.DropItem...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: mud.Room.DropItem[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mud.Room.DropItem)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mud.Room.DropItem,ModifiedNames(changes = UsedName(compose,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(apply,[Default]), UsedName(ne,[Default]), UsedName(DropItem,[Default]), UsedName(andThen,[Default]), UsedName(copy,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(item,[Default]), UsedName(unapply,[Default]), UsedName(mud;Room;DropItem;init;,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(copy$default$1,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]))) invalidates 1 classes due to The mud.Room.DropItem has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(compose,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(apply,[Default]), UsedName(ne,[Default]), UsedName(DropItem,[Default]), UsedName(andThen,[Default]), UsedName(copy,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(item,[Default]), UsedName(unapply,[Default]), UsedName(mud;Room;DropItem;init;,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(copy$default$1,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mud.Room.DropItem)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mud.RoomManager...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: mud.RoomManager[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mud.RoomManager)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mud.RoomManager,ModifiedNames(changes = UsedName(supervisorStrategy,[Default]), UsedName(BeginGame,[Default]), UsedName(aroundReceive,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(Receive,[Default]), UsedName(RoomManager,[Default]), UsedName(ne,[Default]), UsedName(self,[Implicit]), UsedName(postStop,[Default]), UsedName(asInstanceOf,[Default]), UsedName(aroundPreRestart,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(unhandled,[Default]), UsedName(postRestart,[Default]), UsedName(receive,[Default]), UsedName(aroundPostRestart,[Default]), UsedName(mud;RoomManager;init;,[Default]), UsedName(finalize,[Default]), UsedName(readRoom,[Default]), UsedName(preRestart,[Default]), UsedName(aroundPreStart,[Default]), UsedName(sender,[Default]), UsedName(readRooms,[Default]), UsedName(context,[Implicit]), UsedName(hashCode,[Default]), UsedName(preStart,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(rooms,[Default]), UsedName(synchronized,[Default]), UsedName(aroundPostStop,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(!=,[Default]))) invalidates 1 classes due to The mud.RoomManager has the following implicit definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(self,[Implicit]), UsedName(context,[Implicit]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mud.RoomManager)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mud.Player.VerifyInput...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: mud.Player.VerifyInput[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mud.Player.VerifyInput)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mud.Player.VerifyInput,ModifiedNames(changes = UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(VerifyInput,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]))) invalidates 1 classes due to The mud.Player.VerifyInput has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(VerifyInput,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mud.Player.VerifyInput)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from tester.TestPlayer...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: tester.TestPlayer[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(tester.TestPlayer)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(tester.TestPlayer,ModifiedNames(changes = UsedName(supervisorStrategy,[Default]), UsedName(aroundReceive,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(Receive,[Default]), UsedName(apply,[Default]), UsedName(ne,[Default]), UsedName(self,[Implicit]), UsedName(postStop,[Default]), UsedName(asInstanceOf,[Default]), UsedName(GetDropTest,[Default]), UsedName(Disconnect,[Default]), UsedName(aroundPreRestart,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(config,[Default]), UsedName(unhandled,[Default]), UsedName(postRestart,[Default]), UsedName(receive,[Default]), UsedName(aroundPostRestart,[Default]), UsedName(finalize,[Default]), UsedName(preRestart,[Default]), UsedName(aroundPreStart,[Default]), UsedName(sender,[Default]), UsedName(TestPlayer,[Default]), UsedName(context,[Implicit]), UsedName(hashCode,[Default]), UsedName(preStart,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(aroundPostStop,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(gs,[Default]), UsedName(!=,[Default]))) invalidates 1 classes due to The tester.TestPlayer has the following implicit definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(self,[Implicit]), UsedName(context,[Implicit]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(tester.TestPlayer)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from tester.Command...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: tester.Command[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(tester.Command)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(tester.Command,ModifiedNames(changes = UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(ne,[Default]), UsedName(isMovement,[Default]), UsedName(asInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(sendCommand,[Default]), UsedName(runCommand,[Default]), UsedName(finalize,[Default]), UsedName(readToMatch,[Default]), UsedName(args,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(Command,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(name,[Default]), UsedName(notify,[Default]), UsedName(isTerminator,[Default]), UsedName(getClass,[Default]), UsedName(!=,[Default]))) invalidates 1 classes due to The tester.Command has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(ne,[Default]), UsedName(isMovement,[Default]), UsedName(asInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(sendCommand,[Default]), UsedName(runCommand,[Default]), UsedName(finalize,[Default]), UsedName(readToMatch,[Default]), UsedName(args,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(Command,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(name,[Default]), UsedName(notify,[Default]), UsedName(isTerminator,[Default]), UsedName(getClass,[Default]), UsedName(!=,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(tester.Command)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mud.PlayerManager.LocatePlayer...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: mud.PlayerManager.LocatePlayer[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mud.PlayerManager.LocatePlayer)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mud.PlayerManager.LocatePlayer,ModifiedNames(changes = UsedName(compose,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(LocatePlayer,[Default]), UsedName(apply,[Default]), UsedName(ne,[Default]), UsedName(andThen,[Default]), UsedName(copy,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(unapply,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(copy$default$1,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(mud;PlayerManager;LocatePlayer;init;,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(player,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]))) invalidates 1 classes due to The mud.PlayerManager.LocatePlayer has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(compose,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(LocatePlayer,[Default]), UsedName(apply,[Default]), UsedName(ne,[Default]), UsedName(andThen,[Default]), UsedName(copy,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(unapply,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(copy$default$1,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(mud;PlayerManager;LocatePlayer;init;,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(player,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mud.PlayerManager.LocatePlayer)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from tester.Player.KillPlayer...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: tester.Player.KillPlayer[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(tester.Player.KillPlayer)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(tester.Player.KillPlayer,ModifiedNames(changes = UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(KillPlayer,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]))) invalidates 1 classes due to The tester.Player.KillPlayer has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(KillPlayer,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(tester.Player.KillPlayer)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mud.Player...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: mud.Player[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mud.Player)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mud.Player,ModifiedNames(changes = UsedName(supervisorStrategy,[Default]), UsedName(aroundReceive,[Default]), UsedName(getFromInventory,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(PrintMessage,[Default]), UsedName(StartRoom,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(addToInventory,[Default]), UsedName(Receive,[Default]), UsedName(ne,[Default]), UsedName(self,[Implicit]), UsedName(postStop,[Default]), UsedName(asInstanceOf,[Default]), UsedName(Init,[Default]), UsedName(inventoryListing,[Default]), UsedName(aroundPreRestart,[Default]), UsedName(GetCurrentRoom,[Default]), UsedName(playerName,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(unhandled,[Default]), UsedName(TakeExit,[Default]), UsedName(postRestart,[Default]), UsedName(receive,[Default]), UsedName(aroundPostRestart,[Default]), UsedName(finalize,[Default]), UsedName(Player,[Default]), UsedName(processCommand,[Default]), UsedName(VerifyInput,[Default]), UsedName(preRestart,[Default]), UsedName(aroundPreStart,[Default]), UsedName(move,[Default]), UsedName(sender,[Default]), UsedName(context,[Implicit]), UsedName(hashCode,[Default]), UsedName(preStart,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(aroundPostStop,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(mud;Player;init;,[Default]), UsedName(PickItem,[Default]), UsedName(getClass,[Default]), UsedName(!=,[Default]))) invalidates 1 classes due to The mud.Player has the following implicit definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(self,[Implicit]), UsedName(context,[Implicit]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mud.Player)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mud.Room.GetExit...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: mud.Room.GetExit[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mud.Room.GetExit)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mud.Room.GetExit,ModifiedNames(changes = UsedName(compose,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(apply,[Default]), UsedName(ne,[Default]), UsedName(andThen,[Default]), UsedName(copy,[Default]), UsedName(asInstanceOf,[Default]), UsedName(dir,[Default]), UsedName(productIterator,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(mud;Room;GetExit;init;,[Default]), UsedName(unapply,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(copy$default$1,[Default]), UsedName(GetExit,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]))) invalidates 1 classes due to The mud.Room.GetExit has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(compose,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(apply,[Default]), UsedName(ne,[Default]), UsedName(andThen,[Default]), UsedName(copy,[Default]), UsedName(asInstanceOf,[Default]), UsedName(dir,[Default]), UsedName(productIterator,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(mud;Room;GetExit;init;,[Default]), UsedName(unapply,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(copy$default$1,[Default]), UsedName(GetExit,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mud.Room.GetExit)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mud.Room.BroadcastInRoom...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: mud.Room.BroadcastInRoom[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mud.Room.BroadcastInRoom)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mud.Room.BroadcastInRoom,ModifiedNames(changes = UsedName(BroadcastInRoom,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(apply,[Default]), UsedName(copy$default$2,[Default]), UsedName(ne,[Default]), UsedName(copy,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(curried,[Default]), UsedName(playerName,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(mud;Room;BroadcastInRoom;init;,[Default]), UsedName(unapply,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(copy$default$1,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(msg,[Default]), UsedName(tupled,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]))) invalidates 1 classes due to The mud.Room.BroadcastInRoom has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(BroadcastInRoom,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(apply,[Default]), UsedName(copy$default$2,[Default]), UsedName(ne,[Default]), UsedName(copy,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(curried,[Default]), UsedName(playerName,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(mud;Room;BroadcastInRoom;init;,[Default]), UsedName(unapply,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(copy$default$1,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(msg,[Default]), UsedName(tupled,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mud.Room.BroadcastInRoom)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mud.Player.PickItem...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: mud.Player.PickItem[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mud.Player.PickItem)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mud.Player.PickItem,ModifiedNames(changes = UsedName(compose,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(apply,[Default]), UsedName(ne,[Default]), UsedName(andThen,[Default]), UsedName(copy,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(unapply,[Default]), UsedName(oitem,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(copy$default$1,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(mud;Player;PickItem;init;,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(PickItem,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]))) invalidates 1 classes due to The mud.Player.PickItem has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(compose,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(apply,[Default]), UsedName(ne,[Default]), UsedName(andThen,[Default]), UsedName(copy,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(unapply,[Default]), UsedName(oitem,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(copy$default$1,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(mud;Player;PickItem;init;,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(PickItem,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mud.Player.PickItem)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mud.Player.StartRoom...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: mud.Player.StartRoom[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mud.Player.StartRoom)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mud.Player.StartRoom,ModifiedNames(changes = UsedName(compose,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(StartRoom,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(apply,[Default]), UsedName(ne,[Default]), UsedName(andThen,[Default]), UsedName(copy,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(unapply,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(copy$default$1,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(mud;Player;StartRoom;init;,[Default]), UsedName(clone,[Default]), UsedName(room,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]))) invalidates 1 classes due to The mud.Player.StartRoom has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(compose,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(StartRoom,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(apply,[Default]), UsedName(ne,[Default]), UsedName(andThen,[Default]), UsedName(copy,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(unapply,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(copy$default$1,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(mud;Player;StartRoom;init;,[Default]), UsedName(clone,[Default]), UsedName(room,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mud.Player.StartRoom)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mud.Room.FullDescription...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: mud.Room.FullDescription[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mud.Room.FullDescription)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mud.Room.FullDescription,ModifiedNames(changes = UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(FullDescription,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]))) invalidates 1 classes due to The mud.Room.FullDescription has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(FullDescription,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mud.Room.FullDescription)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from tester.RoomExit...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: tester.RoomExit[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(tester.RoomExit)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(tester.RoomExit,ModifiedNames(changes = UsedName(isValidForState,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(apply,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(RoomExit,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]))) invalidates 1 classes due to The tester.RoomExit has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(isValidForState,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(apply,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(RoomExit,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(tester.RoomExit)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from graphicsengine3d.Main...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: graphicsengine3d.Main[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(graphicsengine3d.Main)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(graphicsengine3d.Main,ModifiedNames(changes = UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(main,[Default]), UsedName(hostServices,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(Main,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(canvas,[Default]), UsedName(delayedInit,[Default]), UsedName(init,[Default]), UsedName(finalize,[Default]), UsedName(stopApp,[Default]), UsedName(parameters,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(stage,[Default]), UsedName(getClass,[Default]), UsedName(!=,[Default]))) invalidates 1 classes due to The graphicsengine3d.Main has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(main,[Default]), UsedName(hostServices,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(Main,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(canvas,[Default]), UsedName(delayedInit,[Default]), UsedName(init,[Default]), UsedName(finalize,[Default]), UsedName(stopApp,[Default]), UsedName(parameters,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(stage,[Default]), UsedName(getClass,[Default]), UsedName(!=,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(graphicsengine3d.Main)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from tester.TestPlayer.GetDropTest...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: tester.TestPlayer.GetDropTest[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(tester.TestPlayer.GetDropTest)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(tester.TestPlayer.GetDropTest,ModifiedNames(changes = UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(GetDropTest,[Default]), UsedName(productIterator,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]))) invalidates 1 classes due to The tester.TestPlayer.GetDropTest has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(GetDropTest,[Default]), UsedName(productIterator,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(tester.TestPlayer.GetDropTest)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from tester.Unparsed...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: tester.Unparsed[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(tester.Unparsed)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(tester.Unparsed,ModifiedNames(changes = UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(apply,[Default]), UsedName(copy$default$2,[Default]), UsedName(ne,[Default]), UsedName(isMovement,[Default]), UsedName(copy,[Default]), UsedName(asInstanceOf,[Default]), UsedName(Unparsed,[Default]), UsedName(productIterator,[Default]), UsedName(curried,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(unapply,[Default]), UsedName(runCommand,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(copy$default$1,[Default]), UsedName(args,[Default]), UsedName(tester;Unparsed;init;,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(copy$default$3,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(name,[Default]), UsedName(notify,[Default]), UsedName(isTerminator,[Default]), UsedName(getClass,[Default]), UsedName(tupled,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]))) invalidates 1 classes due to The tester.Unparsed has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(apply,[Default]), UsedName(copy$default$2,[Default]), UsedName(ne,[Default]), UsedName(isMovement,[Default]), UsedName(copy,[Default]), UsedName(asInstanceOf,[Default]), UsedName(Unparsed,[Default]), UsedName(productIterator,[Default]), UsedName(curried,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(unapply,[Default]), UsedName(runCommand,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(copy$default$1,[Default]), UsedName(args,[Default]), UsedName(tester;Unparsed;init;,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(copy$default$3,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(name,[Default]), UsedName(notify,[Default]), UsedName(isTerminator,[Default]), UsedName(getClass,[Default]), UsedName(tupled,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(tester.Unparsed)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from tester.Player.Connect...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: tester.Player.Connect[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(tester.Player.Connect)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(tester.Player.Connect,ModifiedNames(changes = UsedName(Connect,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]))) invalidates 1 classes due to The tester.Player.Connect has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(Connect,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(tester.Player.Connect)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from tester.IOConfig...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: tester.IOConfig[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(tester.IOConfig)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(tester.IOConfig,ModifiedNames(changes = UsedName(tester;IOConfig;init;,[Default]), UsedName(randomValidMovement,[Default]), UsedName(numCommandsToGive,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(testProcs,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(copy$default$7,[Default]), UsedName(apply,[Default]), UsedName(copy$default$2,[Default]), UsedName(ne,[Default]), UsedName(copy,[Default]), UsedName(asInstanceOf,[Default]), UsedName(IOConfig,[Default]), UsedName(productIterator,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(copy$default$5,[Default]), UsedName(parseElement,[Default]), UsedName(roomOutput,[Default]), UsedName(unapply,[Default]), UsedName(copy$default$8,[Default]), UsedName(copy$default$4,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(copy$default$1,[Default]), UsedName(randomValidCommand,[Default]), UsedName(exitCommand,[Default]), UsedName(roomName,[Default]), UsedName(copy$default$6,[Default]), UsedName(copy$default$9,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(copy$default$3,[Default]), UsedName(exits,[Default]), UsedName(inventoryOutput,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(occupants,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(invItems,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(commands,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(items,[Default]), UsedName(copy$default$10,[Default]), UsedName(!=,[Default]))) invalidates 1 classes due to The tester.IOConfig has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(tester;IOConfig;init;,[Default]), UsedName(randomValidMovement,[Default]), UsedName(numCommandsToGive,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(testProcs,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(copy$default$7,[Default]), UsedName(apply,[Default]), UsedName(copy$default$2,[Default]), UsedName(ne,[Default]), UsedName(copy,[Default]), UsedName(asInstanceOf,[Default]), UsedName(IOConfig,[Default]), UsedName(productIterator,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(copy$default$5,[Default]), UsedName(parseElement,[Default]), UsedName(roomOutput,[Default]), UsedName(unapply,[Default]), UsedName(copy$default$8,[Default]), UsedName(copy$default$4,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(copy$default$1,[Default]), UsedName(randomValidCommand,[Default]), UsedName(exitCommand,[Default]), UsedName(roomName,[Default]), UsedName(copy$default$6,[Default]), UsedName(copy$default$9,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(copy$default$3,[Default]), UsedName(exits,[Default]), UsedName(inventoryOutput,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(occupants,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(invItems,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(commands,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(items,[Default]), UsedName(copy$default$10,[Default]), UsedName(!=,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(tester.IOConfig)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mud.Room.PlayersInRoom...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: mud.Room.PlayersInRoom[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mud.Room.PlayersInRoom)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mud.Room.PlayersInRoom,ModifiedNames(changes = UsedName(PlayersInRoom,[Default]), UsedName(compose,[Default]), UsedName(mud;Room;PlayersInRoom;init;,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(apply,[Default]), UsedName(ne,[Default]), UsedName(andThen,[Default]), UsedName(copy,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(unapply,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(copy$default$1,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(userL,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]))) invalidates 1 classes due to The mud.Room.PlayersInRoom has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(PlayersInRoom,[Default]), UsedName(compose,[Default]), UsedName(mud;Room;PlayersInRoom;init;,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(apply,[Default]), UsedName(ne,[Default]), UsedName(andThen,[Default]), UsedName(copy,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(unapply,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(copy$default$1,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(userL,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mud.Room.PlayersInRoom)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from tester.IOElement...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: tester.IOElement[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(tester.IOElement)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(tester.IOElement,ModifiedNames(changes = UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(apply,[Default]), UsedName(copy$default$2,[Default]), UsedName(ne,[Default]), UsedName(copy,[Default]), UsedName(asInstanceOf,[Default]), UsedName(groupNumber,[Default]), UsedName(productIterator,[Default]), UsedName(curried,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(unapply,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(copy$default$1,[Default]), UsedName(tester;IOElement;init;,[Default]), UsedName(IOElement,[Default]), UsedName(parseSeq,[Default]), UsedName(parseSingle,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(copy$default$3,[Default]), UsedName(==,[Default]), UsedName(separator,[Default]), UsedName(pattern,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(tupled,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]))) invalidates 1 classes due to The tester.IOElement has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(apply,[Default]), UsedName(copy$default$2,[Default]), UsedName(ne,[Default]), UsedName(copy,[Default]), UsedName(asInstanceOf,[Default]), UsedName(groupNumber,[Default]), UsedName(productIterator,[Default]), UsedName(curried,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(unapply,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(copy$default$1,[Default]), UsedName(tester;IOElement;init;,[Default]), UsedName(IOElement,[Default]), UsedName(parseSeq,[Default]), UsedName(parseSingle,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(copy$default$3,[Default]), UsedName(==,[Default]), UsedName(separator,[Default]), UsedName(pattern,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(tupled,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(tester.IOElement)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mud.Room.AddPlayer...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: mud.Room.AddPlayer[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mud.Room.AddPlayer)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mud.Room.AddPlayer,ModifiedNames(changes = UsedName(compose,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(user,[Default]), UsedName(apply,[Default]), UsedName(ne,[Default]), UsedName(andThen,[Default]), UsedName(copy,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(unapply,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(copy$default$1,[Default]), UsedName(AddPlayer,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(mud;Room;AddPlayer;init;,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]))) invalidates 1 classes due to The mud.Room.AddPlayer has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(compose,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(user,[Default]), UsedName(apply,[Default]), UsedName(ne,[Default]), UsedName(andThen,[Default]), UsedName(copy,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(unapply,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(copy$default$1,[Default]), UsedName(AddPlayer,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(mud;Room;AddPlayer;init;,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mud.Room.AddPlayer)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mud.Room.RemovePlayer...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: mud.Room.RemovePlayer[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mud.Room.RemovePlayer)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mud.Room.RemovePlayer,ModifiedNames(changes = UsedName(compose,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(user,[Default]), UsedName(apply,[Default]), UsedName(mud;Room;RemovePlayer;init;,[Default]), UsedName(ne,[Default]), UsedName(andThen,[Default]), UsedName(copy,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(unapply,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(copy$default$1,[Default]), UsedName(RemovePlayer,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]))) invalidates 1 classes due to The mud.Room.RemovePlayer has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(compose,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(user,[Default]), UsedName(apply,[Default]), UsedName(mud;Room;RemovePlayer;init;,[Default]), UsedName(ne,[Default]), UsedName(andThen,[Default]), UsedName(copy,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(unapply,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(copy$default$1,[Default]), UsedName(RemovePlayer,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mud.Room.RemovePlayer)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from tester.TestPlayer.Disconnect...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: tester.TestPlayer.Disconnect[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(tester.TestPlayer.Disconnect)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(tester.TestPlayer.Disconnect,ModifiedNames(changes = UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(Disconnect,[Default]), UsedName(productIterator,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]))) invalidates 1 classes due to The tester.TestPlayer.Disconnect has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(Disconnect,[Default]), UsedName(productIterator,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(tester.TestPlayer.Disconnect)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mud.PlayerManager.NewUser...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: mud.PlayerManager.NewUser[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mud.PlayerManager.NewUser)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mud.PlayerManager.NewUser,ModifiedNames(changes = UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(in,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(sock,[Default]), UsedName(apply,[Default]), UsedName(copy$default$2,[Default]), UsedName(ne,[Default]), UsedName(copy,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(curried,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(copy$default$5,[Default]), UsedName(mud;PlayerManager;NewUser;init;,[Default]), UsedName(unapply,[Default]), UsedName(roomManager,[Default]), UsedName(copy$default$4,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(copy$default$1,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(copy$default$3,[Default]), UsedName(NewUser,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(out,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(name,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(tupled,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]))) invalidates 1 classes due to The mud.PlayerManager.NewUser has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(in,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(sock,[Default]), UsedName(apply,[Default]), UsedName(copy$default$2,[Default]), UsedName(ne,[Default]), UsedName(copy,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(curried,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(copy$default$5,[Default]), UsedName(mud;PlayerManager;NewUser;init;,[Default]), UsedName(unapply,[Default]), UsedName(roomManager,[Default]), UsedName(copy$default$4,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(copy$default$1,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(copy$default$3,[Default]), UsedName(NewUser,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(out,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(name,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(tupled,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mud.PlayerManager.NewUser)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mud.Item...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: mud.Item[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mud.Item)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mud.Item,ModifiedNames(changes = UsedName(Item,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(apply,[Default]), UsedName(copy$default$2,[Default]), UsedName(ne,[Default]), UsedName(copy,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(curried,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(unapply,[Default]), UsedName(desc,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(copy$default$1,[Default]), UsedName(mud;Item;init;,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(name,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(tupled,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]))) invalidates 1 classes due to The mud.Item has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(Item,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(apply,[Default]), UsedName(copy$default$2,[Default]), UsedName(ne,[Default]), UsedName(copy,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(curried,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(unapply,[Default]), UsedName(desc,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(copy$default$1,[Default]), UsedName(mud;Item;init;,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(name,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(tupled,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mud.Item)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mud.RoomManager.BeginGame...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: mud.RoomManager.BeginGame[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mud.RoomManager.BeginGame)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mud.RoomManager.BeginGame,ModifiedNames(changes = UsedName(BeginGame,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]))) invalidates 1 classes due to The mud.RoomManager.BeginGame has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(BeginGame,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mud.RoomManager.BeginGame)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mud.PlayerManager.Init...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: mud.PlayerManager.Init[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mud.PlayerManager.Init)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mud.PlayerManager.Init,ModifiedNames(changes = UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(Init,[Default]), UsedName(productIterator,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]))) invalidates 1 classes due to The mud.PlayerManager.Init has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(Init,[Default]), UsedName(productIterator,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mud.PlayerManager.Init)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from tester.RoomOccupant...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: tester.RoomOccupant[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(tester.RoomOccupant)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(tester.RoomOccupant,ModifiedNames(changes = UsedName(isValidForState,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(RoomOccupant,[Default]), UsedName(apply,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]))) invalidates 1 classes due to The tester.RoomOccupant has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(isValidForState,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(RoomOccupant,[Default]), UsedName(apply,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(tester.RoomOccupant)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from tester.RoomItem...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: tester.RoomItem[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(tester.RoomItem)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(tester.RoomItem,ModifiedNames(changes = UsedName(isValidForState,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(apply,[Default]), UsedName(ne,[Default]), UsedName(RoomItem,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]))) invalidates 1 classes due to The tester.RoomItem has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(isValidForState,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(apply,[Default]), UsedName(ne,[Default]), UsedName(RoomItem,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(tester.RoomItem)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mud.Player.Init...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: mud.Player.Init[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mud.Player.Init)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mud.Player.Init,ModifiedNames(changes = UsedName(compose,[Default]), UsedName(mud;Player;Init;init;,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(apply,[Default]), UsedName(ne,[Default]), UsedName(andThen,[Default]), UsedName(copy,[Default]), UsedName(asInstanceOf,[Default]), UsedName(Init,[Default]), UsedName(productIterator,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(unapply,[Default]), UsedName(roomManager,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(copy$default$1,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]))) invalidates 1 classes due to The mud.Player.Init has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(compose,[Default]), UsedName(mud;Player;Init;init;,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(apply,[Default]), UsedName(ne,[Default]), UsedName(andThen,[Default]), UsedName(copy,[Default]), UsedName(asInstanceOf,[Default]), UsedName(Init,[Default]), UsedName(productIterator,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(unapply,[Default]), UsedName(roomManager,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(copy$default$1,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mud.Player.Init)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mud.Room...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: mud.Room[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mud.Room)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mud.Room,ModifiedNames(changes = UsedName(PlayersInRoom,[Default]), UsedName(supervisorStrategy,[Default]), UsedName(aroundReceive,[Default]), UsedName(BroadcastInRoom,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(mud;Room;init;,[Default]), UsedName(Receive,[Default]), UsedName(getItem,[Default]), UsedName(ne,[Default]), UsedName(DropItem,[Default]), UsedName(self,[Implicit]), UsedName(postStop,[Default]), UsedName(asInstanceOf,[Default]), UsedName(Room,[Default]), UsedName(aroundPreRestart,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(fullDescription,[Default]), UsedName(unhandled,[Default]), UsedName(dropItem,[Default]), UsedName(GetItem,[Default]), UsedName(postRestart,[Default]), UsedName(desc,[Default]), UsedName(receive,[Default]), UsedName(aroundPostRestart,[Default]), UsedName(LinkExits,[Default]), UsedName(finalize,[Default]), UsedName(preRestart,[Default]), UsedName(RemovePlayer,[Default]), UsedName(itemFormat,[Default]), UsedName(aroundPreStart,[Default]), UsedName(getExit,[Default]), UsedName(GetExit,[Default]), UsedName(FullDescription,[Default]), UsedName(sender,[Default]), UsedName(AddPlayer,[Default]), UsedName(context,[Implicit]), UsedName(hashCode,[Default]), UsedName(preStart,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(aroundPostStop,[Default]), UsedName(wait,[Default]), UsedName(name,[Default]), UsedName(notify,[Default]), UsedName(exitFormat,[Default]), UsedName(getClass,[Default]), UsedName(!=,[Default]))) invalidates 1 classes due to The mud.Room has the following implicit definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(self,[Implicit]), UsedName(context,[Implicit]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mud.Room)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from tester.Player.GameState...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: tester.Player.GameState[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(tester.Player.GameState)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(tester.Player.GameState,ModifiedNames(changes = UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(apply,[Default]), UsedName(copy$default$2,[Default]), UsedName(ne,[Default]), UsedName(copy,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(curried,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(copy$default$5,[Default]), UsedName(players,[Default]), UsedName(unapply,[Default]), UsedName(copy$default$4,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(copy$default$1,[Default]), UsedName(roomName,[Default]), UsedName(GameState,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(copy$default$3,[Default]), UsedName(exits,[Default]), UsedName(roomItems,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(inventory,[Default]), UsedName(getClass,[Default]), UsedName(tester;Player;GameState;init;,[Default]), UsedName(tupled,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]))) invalidates 1 classes due to The tester.Player.GameState has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(apply,[Default]), UsedName(copy$default$2,[Default]), UsedName(ne,[Default]), UsedName(copy,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(curried,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(copy$default$5,[Default]), UsedName(players,[Default]), UsedName(unapply,[Default]), UsedName(copy$default$4,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(copy$default$1,[Default]), UsedName(roomName,[Default]), UsedName(GameState,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(copy$default$3,[Default]), UsedName(exits,[Default]), UsedName(roomItems,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(inventory,[Default]), UsedName(getClass,[Default]), UsedName(tester;Player;GameState;init;,[Default]), UsedName(tupled,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(tester.Player.GameState)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from tester.RoomParsing...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: tester.RoomParsing[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(tester.RoomParsing)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(tester.RoomParsing,ModifiedNames(changes = UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(apply,[Default]), UsedName(copy$default$2,[Default]), UsedName(ne,[Default]), UsedName(isMovement,[Default]), UsedName(copy,[Default]), UsedName(tester;RoomParsing;init;,[Default]), UsedName(asInstanceOf,[Default]), UsedName(RoomParsing,[Default]), UsedName(productIterator,[Default]), UsedName(curried,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(unapply,[Default]), UsedName(runCommand,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(copy$default$1,[Default]), UsedName(args,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(copy$default$3,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(name,[Default]), UsedName(notify,[Default]), UsedName(isTerminator,[Default]), UsedName(getClass,[Default]), UsedName(tupled,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]))) invalidates 1 classes due to The tester.RoomParsing has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(apply,[Default]), UsedName(copy$default$2,[Default]), UsedName(ne,[Default]), UsedName(isMovement,[Default]), UsedName(copy,[Default]), UsedName(tester;RoomParsing;init;,[Default]), UsedName(asInstanceOf,[Default]), UsedName(RoomParsing,[Default]), UsedName(productIterator,[Default]), UsedName(curried,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(unapply,[Default]), UsedName(runCommand,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(copy$default$1,[Default]), UsedName(args,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(copy$default$3,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(name,[Default]), UsedName(notify,[Default]), UsedName(isTerminator,[Default]), UsedName(getClass,[Default]), UsedName(tupled,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(tester.RoomParsing)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from tester.Player...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: tester.Player[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(tester.Player)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(tester.Player,ModifiedNames(changes = UsedName(Connect,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(Disconnect,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(finalize,[Default]), UsedName(Player,[Default]), UsedName(KillPlayer,[Default]), UsedName(GameState,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(!=,[Default]))) invalidates 1 classes due to The tester.Player has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(Connect,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(Disconnect,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(finalize,[Default]), UsedName(Player,[Default]), UsedName(KillPlayer,[Default]), UsedName(GameState,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(!=,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(tester.Player)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mud.Main...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: mud.Main[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mud.Main)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mud.Main,ModifiedNames(changes = UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(main,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(Main,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(finalize,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(!=,[Default]))) invalidates 1 classes due to The mud.Main has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(main,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(Main,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(finalize,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(!=,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mud.Main)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from tester.InvParsing...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: tester.InvParsing[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(tester.InvParsing)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(tester.InvParsing,ModifiedNames(changes = UsedName(tester;InvParsing;init;,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(apply,[Default]), UsedName(copy$default$2,[Default]), UsedName(ne,[Default]), UsedName(isMovement,[Default]), UsedName(copy,[Default]), UsedName(asInstanceOf,[Default]), UsedName(InvParsing,[Default]), UsedName(productIterator,[Default]), UsedName(curried,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(unapply,[Default]), UsedName(runCommand,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(copy$default$1,[Default]), UsedName(args,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(name,[Default]), UsedName(notify,[Default]), UsedName(isTerminator,[Default]), UsedName(getClass,[Default]), UsedName(tupled,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]))) invalidates 1 classes due to The tester.InvParsing has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(tester;InvParsing;init;,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(apply,[Default]), UsedName(copy$default$2,[Default]), UsedName(ne,[Default]), UsedName(isMovement,[Default]), UsedName(copy,[Default]), UsedName(asInstanceOf,[Default]), UsedName(InvParsing,[Default]), UsedName(productIterator,[Default]), UsedName(curried,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(unapply,[Default]), UsedName(runCommand,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(copy$default$1,[Default]), UsedName(args,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(name,[Default]), UsedName(notify,[Default]), UsedName(isTerminator,[Default]), UsedName(getClass,[Default]), UsedName(tupled,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(tester.InvParsing)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from tester.ConstantArg...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: tester.ConstantArg[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(tester.ConstantArg)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(tester.ConstantArg,ModifiedNames(changes = UsedName(value,[Default]), UsedName(compose,[Default]), UsedName(isValidForState,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(apply,[Default]), UsedName(ne,[Default]), UsedName(andThen,[Default]), UsedName(copy,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(tester;ConstantArg;init;,[Default]), UsedName(unapply,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(copy$default$1,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(ConstantArg,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]))) invalidates 1 classes due to The tester.ConstantArg has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(value,[Default]), UsedName(compose,[Default]), UsedName(isValidForState,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(apply,[Default]), UsedName(ne,[Default]), UsedName(andThen,[Default]), UsedName(copy,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(tester;ConstantArg;init;,[Default]), UsedName(unapply,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(copy$default$1,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(ConstantArg,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(tester.ConstantArg)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mud.Room.GetItem...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: mud.Room.GetItem[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mud.Room.GetItem)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mud.Room.GetItem,ModifiedNames(changes = UsedName(compose,[Default]), UsedName(mud;Room;GetItem;init;,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(apply,[Default]), UsedName(ne,[Default]), UsedName(andThen,[Default]), UsedName(copy,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(unapply,[Default]), UsedName(GetItem,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(copy$default$1,[Default]), UsedName(itemName,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]))) invalidates 1 classes due to The mud.Room.GetItem has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(compose,[Default]), UsedName(mud;Room;GetItem;init;,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(apply,[Default]), UsedName(ne,[Default]), UsedName(andThen,[Default]), UsedName(copy,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(unapply,[Default]), UsedName(GetItem,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(copy$default$1,[Default]), UsedName(itemName,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mud.Room.GetItem)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mud.Player.GetCurrentRoom...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: mud.Player.GetCurrentRoom[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mud.Player.GetCurrentRoom)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mud.Player.GetCurrentRoom,ModifiedNames(changes = UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(GetCurrentRoom,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]))) invalidates 1 classes due to The mud.Player.GetCurrentRoom has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(GetCurrentRoom,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mud.Player.GetCurrentRoom)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mud.PlayerManager.PrivateMessage...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: mud.PlayerManager.PrivateMessage[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mud.PlayerManager.PrivateMessage)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mud.PlayerManager.PrivateMessage,ModifiedNames(changes = UsedName(mud;PlayerManager;PrivateMessage;init;,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(apply,[Default]), UsedName(copy$default$2,[Default]), UsedName(ne,[Default]), UsedName(copy,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(curried,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(PrivateMessage,[Default]), UsedName(unapply,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(copy$default$1,[Default]), UsedName(sender,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(copy$default$3,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(receiver,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(msg,[Default]), UsedName(tupled,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]))) invalidates 1 classes due to The mud.PlayerManager.PrivateMessage has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(mud;PlayerManager;PrivateMessage;init;,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(apply,[Default]), UsedName(copy$default$2,[Default]), UsedName(ne,[Default]), UsedName(copy,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(curried,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(PrivateMessage,[Default]), UsedName(unapply,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(copy$default$1,[Default]), UsedName(sender,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(copy$default$3,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(receiver,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(msg,[Default]), UsedName(tupled,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mud.PlayerManager.PrivateMessage)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mud.Player.PrintMessage...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: mud.Player.PrintMessage[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mud.Player.PrintMessage)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mud.Player.PrintMessage,ModifiedNames(changes = UsedName(compose,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(PrintMessage,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(apply,[Default]), UsedName(ne,[Default]), UsedName(andThen,[Default]), UsedName(copy,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(mud;Player;PrintMessage;init;,[Default]), UsedName(unapply,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(copy$default$1,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(msg,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]))) invalidates 1 classes due to The mud.Player.PrintMessage has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(compose,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(PrintMessage,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(apply,[Default]), UsedName(ne,[Default]), UsedName(andThen,[Default]), UsedName(copy,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(mud;Player;PrintMessage;init;,[Default]), UsedName(unapply,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(copy$default$1,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(msg,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mud.Player.PrintMessage)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from tester.Player.Disconnect...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: tester.Player.Disconnect[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(tester.Player.Disconnect)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(tester.Player.Disconnect,ModifiedNames(changes = UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(Disconnect,[Default]), UsedName(productIterator,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]))) invalidates 1 classes due to The tester.Player.Disconnect has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(Disconnect,[Default]), UsedName(productIterator,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(tester.Player.Disconnect)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mud.Room.LinkExits...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: mud.Room.LinkExits[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mud.Room.LinkExits)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mud.Room.LinkExits,ModifiedNames(changes = UsedName(compose,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(apply,[Default]), UsedName(ne,[Default]), UsedName(andThen,[Default]), UsedName(copy,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(mud;Room;LinkExits;init;,[Default]), UsedName(unapply,[Default]), UsedName(LinkExits,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(copy$default$1,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(rooms,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]))) invalidates 1 classes due to The mud.Room.LinkExits has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(compose,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(apply,[Default]), UsedName(ne,[Default]), UsedName(andThen,[Default]), UsedName(copy,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(mud;Room;LinkExits;init;,[Default]), UsedName(unapply,[Default]), UsedName(LinkExits,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(copy$default$1,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(rooms,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mud.Room.LinkExits)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from tester.Debug...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: tester.Debug[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(tester.Debug)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(tester.Debug,ModifiedNames(changes = UsedName(monitoredRooms,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(playerDebugPrint,[Default]), UsedName(roomDebugPrint,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(regexDebugPrint,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(finalize,[Default]), UsedName(roomDebugLevel,[Default]), UsedName(Debug,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(playerDebugLevel,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(regexDebugLevel,[Default]), UsedName(!=,[Default]))) invalidates 1 classes due to The tester.Debug has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(monitoredRooms,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(playerDebugPrint,[Default]), UsedName(roomDebugPrint,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(regexDebugPrint,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(finalize,[Default]), UsedName(roomDebugLevel,[Default]), UsedName(Debug,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(playerDebugLevel,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(regexDebugLevel,[Default]), UsedName(!=,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(tester.Debug)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mud.PlayerManager.CheckInput...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: mud.PlayerManager.CheckInput[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mud.PlayerManager.CheckInput)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mud.PlayerManager.CheckInput,ModifiedNames(changes = UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(CheckInput,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]))) invalidates 1 classes due to The mud.PlayerManager.CheckInput has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(CheckInput,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mud.PlayerManager.CheckInput)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from tester.SimpleTest...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: tester.SimpleTest[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(tester.SimpleTest)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(tester.SimpleTest,ModifiedNames(changes = UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(is,[Default]), UsedName(main,[Default]), UsedName(os,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(executionStart,[Default]), UsedName(ioConfig,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(delayedInit,[Default]), UsedName(finalize,[Default]), UsedName(args,[Default]), UsedName(SimpleTest,[Default]), UsedName(system,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(player,[Default]), UsedName(getClass,[Default]), UsedName(process,[Default]), UsedName(!=,[Default]))) invalidates 1 classes due to The tester.SimpleTest has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(is,[Default]), UsedName(main,[Default]), UsedName(os,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(executionStart,[Default]), UsedName(ioConfig,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(delayedInit,[Default]), UsedName(finalize,[Default]), UsedName(args,[Default]), UsedName(SimpleTest,[Default]), UsedName(system,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(player,[Default]), UsedName(getClass,[Default]), UsedName(process,[Default]), UsedName(!=,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(tester.SimpleTest)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from mud.Player.TakeExit...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: mud.Player.TakeExit[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(mud.Player.TakeExit)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(mud.Player.TakeExit,ModifiedNames(changes = UsedName(compose,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(apply,[Default]), UsedName(ne,[Default]), UsedName(andThen,[Default]), UsedName(copy,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(TakeExit,[Default]), UsedName(unapply,[Default]), UsedName(mud;Player;TakeExit;init;,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(copy$default$1,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(oroom,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]))) invalidates 1 classes due to The mud.Player.TakeExit has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(compose,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(apply,[Default]), UsedName(ne,[Default]), UsedName(andThen,[Default]), UsedName(copy,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(TakeExit,[Default]), UsedName(unapply,[Default]), UsedName(mud;Player;TakeExit;init;,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(copy$default$1,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(oroom,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(mud.Player.TakeExit)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from tester.CommandArgument...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: tester.CommandArgument[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(tester.CommandArgument)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(tester.CommandArgument,ModifiedNames(changes = UsedName(isValidForState,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(apply,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(CommandArgument,[Default]), UsedName(finalize,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(!=,[Default]))) invalidates 1 classes due to The tester.CommandArgument has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(isValidForState,[Default]), UsedName(notifyAll,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(apply,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(CommandArgument,[Default]), UsedName(finalize,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(!=,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(tester.CommandArgument)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from tester.InvItem...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: tester.InvItem[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(tester.InvItem)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(tester.InvItem,ModifiedNames(changes = UsedName(isValidForState,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(InvItem,[Default]), UsedName(apply,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]))) invalidates 1 classes due to The tester.InvItem has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(isValidForState,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(##,[Default]), UsedName(equals,[Default]), UsedName(InvItem,[Default]), UsedName(apply,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productIterator,[Default]), UsedName(toString,[Default]), UsedName(eq,[Default]), UsedName(productPrefix,[Default]), UsedName(finalize,[Default]), UsedName(productElement,[Default]), UsedName(hashCode,[Default]), UsedName(==,[Default]), UsedName(clone,[Default]), UsedName(isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(canEqual,[Default]), UsedName(wait,[Default]), UsedName(notify,[Default]), UsedName(getClass,[Default]), UsedName(productArity,[Default]), UsedName(!=,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(tester.InvItem)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mNew invalidations:[0m
[0m[[0m[0mdebug[0m] [0m[0m	Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: [0m
[0m[[0m[0mdebug[0m] [0m[0mPreviously invalidated, but (transitively) depend on new invalidations:[0m
[0m[[0m[0mdebug[0m] [0m[0m	Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mNo classes were invalidated.[0m
